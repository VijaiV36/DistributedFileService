// Name : Vishal Sreeram
// UTA ID: 1001535749
// NetID: vxs5750

// References:
// 1.https://www.geeksforgeeks.org/multi-threaded-chat-application-set-1/
// 2.https://www.geeksforgeeks.org/multi-threaded-chat-application-set-2/
// 3.https://www.javadevjournal.com/java/java-copy-file-directory/
// 4.https://github.com/NishadKumar/string-matching-plagiarism-detect/blob/master/PlagiarismDetection/src/DetectPlagiarism.java
// 5.https://www.rgagnon.com/javadetails/java-0490.html
// 6.http://www.avajava.com/tutorials/lessons/whats-a-quick-way-to-tell-if-the-contents-of-two-files-are-identical-or-not.html
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package DSProject1;

import static DSProject1.Client.username;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.LinkedList;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Queue;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import org.apache.maven.shared.utils.io.FileUtils;

/**
 *
 * @author Vijai.V
 */
public class Server extends javax.swing.JFrame {
    static String username;// String to store the username
    static InetAddress ip;// Storing the Inet Address.
    static Socket soc;//Name of the Socket
    static DataOutputStream dos;//Name of the DataOutputStream
    static DataInputStream dis;//Name of the DataInputStream
    final static int ServerPort = 7654; // initializing the Server Port Number.

    
    static ServerSocket serversocket;// Name of the Server Socket
    static int i = 0; // used to iterate each client.
    /**
     * Creates new form Server
     */
    public Server() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Stop Server");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(179, 179, 179)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(69, 69, 69)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 344, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(68, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(39, 39, 39)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(24, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(null,"Server is gonna stop!");
        System.out.println("Server Shutdown");
        // If server faces any issues, 
        //this makes sure that all of the clients get disconnected and logs out 
        for(ClientHandler mc:Server.ar){
            try {
                if(mc.isloggedin){
                mc.dos.writeUTF("logout");
                mc.isloggedin=false; 
                mc.soc.close();
                }
            } catch (IOException ex) {
                Logger.getLogger(Server.class.getName()).log(Level.SEVERE, null, ex);
            }
            new File("Server").delete();// deletes the server's directory
        }
        System.exit(0);
    }//GEN-LAST:event_jButton1ActionPerformed
        static Vector<ClientHandler> ar = new Vector<>();// used to handle each and every client active.
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws IOException{
        
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Server.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Server.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Server.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Server.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Server().setVisible(true);
            }
        });
       try{
        ArrayList<String> userd=new ArrayList<String>();// ArrayList to store the list of available users
        serversocket = new ServerSocket(ServerPort);// bind the socket
        File directory = new File("Server");
        if (directory.exists()) {
            System.out.println("Directory already exists ...");

        } else {
            System.out.println("Directory not exists, creating now");
            directory.mkdir();
        }
        while(true)
        {  
            soc = serversocket.accept();// The serversocket is now listening for connections 
            jTextArea1.append("\nNew client request received : " + soc); 
            jTextArea1.append(""+soc.getInetAddress());
            // obtain input and output streams 
            dis = new DataInputStream(soc.getInputStream()); 
            dos = new DataOutputStream(soc.getOutputStream()); 
          
            jTextArea1.append("\nCreating a new handler for this client..."); 
            username = dis.readUTF(); 
            if(!userd.contains(username))
           { 
               System.out.println(username);
            
            userd.add(username);
            
            
            
            // displaying the Client's Socket details.
            jTextArea1.append("\nNew client request received : \n " + soc+ " "+username);
            jTextArea1.append("\n"+" Connected..."+"\n" );
            jTextArea1.append("\nCreating a new handler for this client...Adding this client to active client list");
            
            // Assigning a ClientHandler for the client;
            ClientHandler mtch = new ClientHandler(soc,"client " + i, dis, dos,username);
            Thread t = new Thread(mtch); // Assigning a thread for each client.
            jTextArea1.append("\nAdding this client to active client list"); 
            
            File dir=new File(username);// a directory is created based on the username of the client
            if(dir.exists()){
                System.out.println("Directory already exists ...");
            }
            else {
            System.out.println("Directory not exists, creating now");

            boolean success = dir.mkdir();
            if (success) {
                System.out.printf("Successfully created new directory : %s%n", dir);
                File f=new File(dir,"file.txt");
                f.createNewFile();
                
            } else {
                System.out.printf("Failed to create new directory: %s%n", dir);
            }
        }
            dos.writeUTF("Welcome "+username);
            // add this client to active clients list 
            ar.add(mtch); 
  
            // start the thread. 
            t.start();   
        }
            else{
                dos.writeUTF("already exits");
            }
            i++;// for next client
            
            // Displaying the list of Avalible Users to the Server.
            jTextArea1.append("\nList of available users\n");
            for(ClientHandler mc:Server.ar){
                       jTextArea1.append("\n"+mc.userName);
                       }
        }
       }
       catch(Exception e){} 
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JScrollPane jScrollPane1;
    private static javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}
class ClientHandler implements Runnable{
Scanner scn = new Scanner(System.in); 
    private String name; //Name of the Client
    final DataInputStream dis; //Name of the DataInputStream
    final DataOutputStream dos; // Name of the DataOutputStream
    Socket soc; // Name of the socket
    boolean isloggedin; // to checkwhether the client is loggedin or not
    String userName;// UserName of the given Client
    String received;// String to store the message from the Client.
    
// The Following Constructor is used to handle a particular client's Socket, Stream Details.
    public ClientHandler(Socket s, String name, DataInputStream dis, DataOutputStream dos, String user) {
        this.dis = dis; 
        this.dos = dos; 
        this.name = user; 
        this.soc = s; 
        this.isloggedin=true; 
        this.userName=user;
    }
       public void listFilesForFolder(File folder,DataOutputStream dos) throws IOException 
{
    if(folder.list().length>0)
    for (final File fileEntry : folder.listFiles()) {
        if (fileEntry.isDirectory()) {
            listFilesForFolder(fileEntry,dos);
        } else {
            dos.writeUTF("\n"+fileEntry.getName());
        }
    }
    else{
        dos.writeUTF("No file found");
    }
}
    @Override
    public void run() {
        // While the User is logged into the system, this loop executes.
       while (this.isloggedin)  
        {   
            try
            {
                
                // receive the message from the client after an operations is performed. 
                received = dis.readUTF(); // the message received is read and then printed on to console output.
                System.out.println("received msg:"+received);
                
                // In case, a client logs out of the system.
                // loggedin is set to false, The following messages are displayed on the Output Window
                // and the socket is closed.
                if(received.equals("logout")){ 
                    System.out.println("Client "+userName+" requested logout");
                    System.out.println("Client "+userName+ " disconnected");
                    this.isloggedin=false;
                    new File(userName).delete();
                    System.out.println("List of current users");
                   for(ClientHandler mc:Server.ar){
                       if(mc.isloggedin){
                           System.out.println(mc.userName);
                       }
                   }
                    this.soc.close(); 
                    break; 
                }
                if(received.contains("modify||")){
                  StringTokenizer st = new StringTokenizer(received, "||");
                  String action=st.nextToken();
                  String dirName=st.nextToken();
                  String fileName=st.nextToken();
        for(ClientHandler mc:Server.ar)
                    {
                    // This is where the file upload happens
                    // checks for the clients other than the one which has uploaded,
                    // notifications are sent to all other clients about the new file upload,
                    // the file is copied to the other client's directory,
                    if(!mc.name.equals(this.name)){
                       
                       Path sourceDirectory = Paths.get(dirName+"/"+fileName);
  Path targetDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +mc.userName+"/"+fileName);

        try {
            //copying of the file from source dir to target dir is done is done here
            if(FileUtils.contentEquals(new File(sourceDirectory.toString()),new File(targetDirectory.toString()))){
                
            }
            else{
            mc.dos.writeUTF("\nInvalidation Notice, changes were made by client "+this.userName);
            Files.copy(sourceDirectory, targetDirectory,StandardCopyOption.REPLACE_EXISTING);
            
            mc.dos.writeUTF("\nList of files present in directory");
            listFilesForFolder(new File(mc.userName),mc.dos);}
        } catch (Exception ex) {
          
        }
                    }
        }
                }
                else if(received.contains("delete||")){
                  StringTokenizer st = new StringTokenizer(received, "||");
                  String action=st.nextToken();
                  String userName1=st.nextToken();
                  String fileName=st.nextToken();
        for(ClientHandler mc:Server.ar)
                    {
                    // This is where the file upload happens
                    // checks for the clients other than the one which has uploaded,
                    // notifications are sent to all other clients about the new file upload,
                    // the file is copied to the other client's directory,
                    if(!mc.name.equals(this.name)){
  Path targetDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +mc.userName+"/"+fileName);
        try {
           if(FileUtils.fileExists(targetDirectory.toString())){
               mc.dos.writeUTF("\nThe client #"+userName1+"# is requesting to delete the file#"+fileName);
           } 
           else{
                
           }
          
        } catch (Exception ex) {
          
        }
                    }
        }    
                }
                
                else if(received.contains("Vote is ")){
                  StringTokenizer st = new StringTokenizer(received, "#");
                  String action=st.nextToken();
                  String decision=st.nextToken();
                  String fileName=st.nextToken();
                  String coord=st.nextToken();
        for(ClientHandler mc:Server.ar){
             
             if(mc.name.equals(coord)){
                 mc.dos.writeUTF("\n"+this.name+"# has voted #"+decision+"#"+fileName+"#\n");
             }
         }        
                }// if stmt for Vote
                else if(received.contains("Decision is ")){
                   StringTokenizer st = new StringTokenizer(received, "#");
                   String content=st.nextToken();
                   String decision=st.nextToken();
                   String file=st.nextToken();
                   if(decision.equals("delete")){
                      for(ClientHandler mc:Server.ar){
//                          System.out.println(mc.name+" "+this.name);
                       if(!mc.name.equals(this.name)){
                           mc.dos.writeUTF("Ok to delete");
          Path targetDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +mc.userName+"/"+file);
          Files.delete(targetDirectory); 
                       }
                   } 
                   }
                   else
                   {
                      for(ClientHandler mc:Server.ar){
                       if(!mc.name.equals(this.name)){
                           mc.dos.writeUTF("Do not delete");
                       }
    Path sourceDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +mc.userName+"/"+file);
  Path targetDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +this.userName+"/"+file);
        try {
            //copying of the file from source dir to target dir is done is done here
            Files.copy(sourceDirectory, targetDirectory,StandardCopyOption.REPLACE_EXISTING);
        } 
        catch (Exception ex) {
          
        }   
                   }   
                   }
                   
                }
                else
                {
                StringTokenizer st = new StringTokenizer(received, "#"); // # is used to differentiate.
                String dirName = st.nextToken(); // the directory name from which the file is taken
                String fileName = st.nextToken();   // Name of the file to be uploaded  
                                                    
               for(ClientHandler mc:Server.ar)
                    {
                    // This is where the file upload happens
                    // checks for the clients other than the one which has uploaded,
                    // notifications are sent to all other clients about the new file upload,
                    // the file is copied to the other client's directory,
                    if(!mc.name.equals(this.name)){
                       mc.dos.writeUTF("\nNew File to be downloaded!");
                       Path sourceDirectory = Paths.get(dirName);
  Path targetDirectory = Paths.get("/Users/vijai/NetBeansProjects/mavenproject1/DSProject1/"
          +mc.userName+"/"+fileName);

        try {
            //copying of the file from source dir to target dir is done is done here
            Files.copy(sourceDirectory, targetDirectory,StandardCopyOption.REPLACE_EXISTING);
            mc.dos.writeUTF("\nDownload complete!");
            mc.dos.writeUTF("\nList of files present in directory");
            listFilesForFolder(new File(mc.userName),mc.dos);
        } catch (Exception ex) {
          
        }
                    }
        }}   
            }
            catch(Exception e){}
            } 
        try
        { 
            // closing resources 
            this.dis.close(); 
            this.dos.close(); 
              
        }catch(IOException e){ 
            e.printStackTrace(); 
        }     
    }
}
